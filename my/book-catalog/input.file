第1章引言
1.1　什么是设计模式
1.2　Smalltalk MVC中的设计模式
1.3　描述设计模式
1.4　设计模式的编目
1.5　组织编目
1.6　设计模式怎样解决设计问题
1.6.1　寻找合适的对象
1.6.2　决定对象的粒度
1.6.3　指定对象接口
1.6.4　描述对象的实现
1.6.5　运用复用机制
1.6.6　关联运行时和编译时的结构
1.6.7　设计应支持变化
1.7　怎样选择设计模式
1.8　怎样使用设计模式
第2章实例研究：设计一个文档编辑器
2.1　设计问题
2.2　文档结构
2.2.1　递归组合
2.2.2　图元
2.2.3　组合模式
2.3　格式化
2.3.1　封装格式化算法
2.3.2　Compositor和Composition
2.3.3　策略模式
2.4　修饰用户界面
2.4.1　透明围栏
2.4.2　Monoglyph
2.4.3　Decorator模式
2.5　支持多种视感标准
2.5.1　对象创建的抽象
2.5.2　工厂类和产品类
2.5.3　Abstract Factory 模式
2.6　支持多种窗口系统
2.6.1　是否可以使用Abstract Factory模式
2.6.2　封装实现依赖关系
2.6.3　Window和WindowImp
2.6.4　Bridge模式
2.7　用户操作
2.7.1　封装一个请求
2.7.2　Command类及其子类
2.7.3　撤销和重做
2.7.4　命令历史记录
2.7.5　Command模式
2.8　拼写检查和断字处理
2.8.1　访问分散的信息
2.8.2　封装访问和遍历
2.8.3　Iterator类及其子类
2.8.4　Iterator模式
2.8.5　遍历和遍历过程中的动作
2.8.6　封装分析
2.8.7　Visitor类及其子类
2.8.8　Visitor模式
2.9　小结
第3章创建型模式
3.1　Abstract Factory（抽象工厂）—对象创建型模式
3.2　Builder（生成器）—对象创建型模式
3.3　Factory Method（工厂方法）—对象创建型模式
3.4　Prototype（原型）—对象创建型模式
3.5　Singleton（单件）—对象创建型模式
3.6　创建型模式的讨论
第4章结构型模式
4.1　Adapter（适配器）—类对象结构型模式
4.2　Bridge（桥接）—对象结构型模式
4.3　Composite（组合）—对象结构型模式
4.4　Decorator（装饰）—对象结构型模式
4.5　Facade（外观）—对象结构型模式
4.6　Flyweight（享元）—对象结构型模式
4.7　Proxy（代理）—对象结构型模式
4.8　结构型模式的讨论 
4.8.1　Adapter与Bridge
4.8.2　Composite、Decorator与Proxy
第5章行为型模式
5.1　Chain of Responsibility（职责链）—对象行为型模式
5.2　Command（命令）—对象行为型模式
5.3　Interpreter（解释器）—类行为型模式
5.4　Iterator（迭代器）—对象行为型模式
5.5　 Mediator（中介者）—对象行为型模式
5.6　Memento（备忘录）—对象行为型模式
5.7　Observer（观察者）—对象行为型模式
5.8　State（状态）—对象行为型模式
5.9　Strategy（策略）—对象行为型模式
5.10　Template Method（模板方法）— 类行为型模式
5.11　Visitor（访问者）—对象行为型 模式
5.12　行为型模式的讨论
5.12.1　封装变化
5.12.2　对象作为参数
5.12.3　通信应该被封装还是被分布
5.12.4　对发送者和接收者解耦
5.12.5　总结
第6章结论
6.1　设计模式将带来什么
6.1.1　一套通用的设计词汇
6.1.2　书写文档和学习的辅助手段
6.1.3　现有方法的一种补充
6.1.4　重构的目标
6.2　本书简史
6.3　模式界
6.3.1　Alexander的模式语言
6.3.2　软件中的模式
6.4　邀请参与
6.5　临别感想